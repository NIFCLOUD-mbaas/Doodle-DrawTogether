<h1>Doodle機能解説</h1>
<h5>このドキュメントは、「Doodle」の核としての５つの機能の具体的な技術解説です。</h5>
このアプリで使われているmBaas SDKや、ゲーム作業の手順などは、<a href="README.md">readme</a>の方をご覧ください。

<h2 id="keyquestion">機能リスト</h2>
<ul>
  <li><a href="#q1">『機能一』ユーザー登録とログイン（会員管理）</a>
  ★☆☆☆☆</li>
  <li><a href="#q2">『機能二』Doodle(落書き)機能</a>
  ★★★★☆</li>
  <li><a href="#q3">『機能三』画像の保存と取得（ファイルストア）</a>
  ★★☆☆☆</li>
  <li><a href="#q4">『機能四』画像に関するデータの保存と取得（データストア）</a>
  ★☆☆☆☆</li>
  <li><a href="#q5">『機能五』人気ランキング機能（データストア）</a>
  ★★★☆☆</li>
</ul>
<h2>解説流れ</h2>
 <ul>
 		 <li><b>mBaaSの機能について解説(<a href="http://mb.cloud.nifty.com/about.htm">mBaaSとは？</a>)</b><br/>
  		「Doodle」では、mBaaSの「会員管理」、「データストア」、「ファイルストア」の三つの機能を使っています。 問題に対応するmBaaSの機能を紹介します。</li>
  		<li><b>ゲーム機能の説明</b><br/>
		    問題に対応するゲームの機能を紹介します。</li>
		  <li><b>説明対象</b><br/>
		    以下の「主な流れ」で説明する流れに拘るGameobject（スクリプト、ボタンなど）
		  </li>
		  <li><b>主な流れ</b><br/>
		  機能を作成する手順。キーコードとそれに関するUnityの操作を紹介します。
		  </li>
		  <li><b>動作確認</b><br/>
		  操作の結果を、ダッシュボードで確認します。
		  </li>
		  <li><b>ディスカッション</b><br/>
		  問題の解説を見て、御自身も試したいと思ったら、是非ディスカッションの問題をご覧ください！
	  	　<br/>質問の答えは全部プロジェクトのコードにあります。答えを探す方法は<a href="#discussionanswer">こちら</a>。
		  </li>
		  <li><b>ヒント</b><br/>
		  mBaaSに関して注意すべきこと、Unityの便利な機能など、ヒントの部分で紹介します。
		  </li>
</ul>

<h2 id="q1">『機能一』　ユーザー登録とログイン（会員管理）</h2>
<h5>難易度/★☆☆☆☆</h5>
<ul>
  <li><b>mbの会員管理機能について</b><br/>
  	<p>mBaasが提供する機能の一つです。アプリ利用者に会員登録を意識させない形で会員管理を行えます。
  	詳しくは<a href="http://mb.cloud.nifty.com/doc/current/user/basic_usage_unity.html">ドキュメント</a>を参照下さい。
  	</p>
  </li>
  <li><b>説明対象</b><br/>
  【シーン「login」】 <br/>
  <b>「Name」</b>（Inputfield）<br/>
  <b>「Password」</b>（Inputfield）<br/>
  <b>「Login」</b>（Button）<br/>
  <b>「SignUp」</b>（Button）<br/>
  「Controller」Component<b>「ButtonController」</b>（Script）
  </li>
  <li><b>主な流れ</b>
  <p>1. 先ずは、ニックネーム、パスワードを入力するためのInputfield Gameobject「Name」と「Password」を生成します。（<a href="readme-img/01login.gif">動画を見る</a>）<br/>
  2. 登録、ログインのボタンを生成します。（<a href="readme-img/02loginbuttons.gif">動画を見る</a>）<br/>
  3. シーンで「Controller」というEmpty Gameobjectを生成して、「ButtonController.cs」というスクリプトを生成して、「Controller」にドラッグ＆ドロップで追加して下さい。（<a href="readme-img/03ButtonController.gif">動画を見る</a>）
  </p>
  登録ボタンを押下時の処理は以下のように記述します：
  <pre data-lang="c#">
	public InputField nameInput;
	public InputField passwordInput;
	public void OnSignUp(){
		//NCMBUserのインスタンス作成 
		NCMBUser user = new NCMBUser();
		//ユーザ名とパスワードの設定
		user.UserName = nameInput.text;
		user.Password = passwordInput.text;
				
		//会員登録を行う
		user.SignUpAsync((NCMBException e) => { 
			if (e != null) {
				UnityEngine.Debug.Log ("新規登録に失敗: " + e.ErrorMessage);
			} else {
				UnityEngine.Debug.Log ("新規登録に成功");
				//新しいシーンをロード
				Application.LoadLevel("title");
			}
		});
	}
  </pre>
  4. Unityに戻り、「登録」ボタンをクリックします。ボタンのOnClick関数の所にある、「＋」マークをクリックして下さい。
　<p><img src="readme-img/f1-01.jpg"/></p>
  5. 「Controller」の下にドラッグし、OnSignUp()メソッドを選択します。（<a href="readme-img/04SignUpClick.gif">4.と5.の動画を見る</a>）
  <p><img src="readme-img/f1-02.jpg"></p>
   6. 「Controller」をクリックして、ニックネームとパスワードの入力ボックスを「nameInput」と「passwordInput」にドラッグ＆ドロップします。（<a href="readme-img/05DragInputField.gif">動画を見る</a>）
  <p><img src="readme-img/f1-03.jpg"></p>
  </li>
  <li><b>動作確認</b><br/>
  	<ul>
		<li>先ほど保存したユーザー情報はmBaaSのダッシュボード⇒会員管理で見られます：<br/>
			<img src="readme-img/f1-04.png"/>
		</li>
	</ul>
  </li>
  <li><b>ディスカッション</b>
  <br/>ログインとログアウトの機能を追加してみませんか？ ┃難易度★☆☆☆☆
  <br/><b>【アンサー】</b></br>
  <a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/ButtonController.cs">ログインの答え</a> search key: Discussion 1 Log In<br/>
  <a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/ButtonController.cs">ログアウトの答え</a> search key: Discussion 2 Log Out<br/>
  <a href="#discussionanswer">答えを探す方法</a>
  </li>
  <li><b>ヒント</b>
  <br/>- ニックネームとパスワード両方の入力が必要なため、チェックする関数が必要です。
  <br/>- SignUpAsync()関数は、同期処理の関数ではありません。即ち、SignUpAsync()がコールされた後、その執行を待つではなく、コールの後のコートを執行します。
　<br/>- ボタンのOnClick()にGameobjectをドラッグ＆ドロップし、クリックイベントを処理する関数を選ぶ、ということはUnity専有の機能で、使い易いです。
（<a href="readme-img/04SignUpClick.gif">サンプル動画</a>）  
</li>
</ul>
<span><a href="#keyquestion">リストに戻る</a></span>
<h2 id="q2">『機能二』　Doodle(落書き)機能</h2>
<h5>難易度/★★★★☆</h5>
<ul>
  <li>機能の説明<br/>
	<ul>      
	<li>この機能を開発するには、UnityEngineの「LineRenderer」というクラスを利用します。「LineRender」のメソッド「SetPosition()」と「SetPositions()」を利用し、線の頂点を設置することで、絵を描くことが可能になります。</li>
	<li>ですが、一つのLineRenderは一本の線しか描けません。そして、一つのGameobjectは、一つのLineRendererだけに対応します。ですから、複数の線を描くため、複数のGameobjectを生成しなければいけません。</li>
	<li>「LineRenderer」の関して、Unityの<a href="http://docs.unity3d.com/jp/current/ScriptReference/LineRenderer.html">ドキュメント</a>をご参考下さい。</li>
	</ul>
  </li>
　<li><b>説明対象</b><br/>
	【シーン「draw」】 <br/>
	「Line0」Component<b>「LineRenderer」</b>、<b>「DrawLine」</b>(Script)
  </li>
  <li><b>主な流れ</b><br/>
　1. 「DrawLine.cs」というスクリプトを生成します。<br/>
　2. 「DrawLine.cs」で、「defaultRenderer」というLineRendererを定義し、初期化します。
  <pre>
   defaultRenderer = gameObject.GetComponent();
   defaultRenderer.material = new Material (shader);
   defaultRenderer.SetVertexCount (0);
   defaultRenderer.SetWidth (0.1f, 0.1f);
   defaultRenderer.SetColors (Color.green, Color.green);
   defaultRenderer.useWorldSpace = true;
  </pre>
　3. シーンで、「Line0」というGameobjectを生成して、「Add　Component」の所で、「LineRenderer」を生成します。「DrawLine.cs」を「Line0」にドラッグ＆ドロップで追加します。（<a href="readme-img/06LineRenderer2.gif">動画を見る</a>）<br/>
　4. シーンで「DrawingPanel」というパネルを生成し、以下のコードを使って、スクリプトから獲得します。（「DrawingPanel」は絵を描く範囲です。）
  <pre>
  panel = GameObject.Find ("DrawingPanel");
　</pre>
　5. 以下のコードを「DrawLine.cs」のUpdate()に追加します。
  <pre>
	if (Input.GetMouseButtonDown (0)) {
            //to check if this line renderer is used. If it is, create a new line renderer(on a new Gameobject)
            //(so that more than 1 lines can be rendered)
            if(!used){
                used = true;
                isMousePressed = true;
                defaultRenderer.SetVertexCount (0);
                pointList.RemoveRange (0, pointList.Count);
            }else if(!newCreated){
                //to draw more than 1 lines, we have to create a new gameObejct
                GameObject newRenderer = GameObject.Instantiate (rendererPrefab);
                newCreated = true;
                newRenderer.GetComponent ().init();
            }
        }
        if (Input.GetMouseButtonUp (0)) {
            isMousePressed = false;}
        if (isMousePressed && IfInDrawingCanvas()) {
		mousePos = Camera.main.ScreenToWorldPoint (Input.mousePosition);
		mousePos.z = 0;
		if (!pointList.Contains (mousePos)) {
			pointList.Add (mousePos);
			defaultRenderer.SetVertexCount (pointList.Count);
			defaultRenderer.SetPosition (pointList.Count - 1, (Vector3)pointList [pointList.Count - 1]);
		}
	}
  </pre>
  以上のスクリプトで使われる変数の定義：
  <pre>
	private bool isMousePressed = false;
	public List<Vector3> pointList;
	private Vector3 mousePos;
	private LineRenderer defaultRenderer;
	private bool used = false;
	private bool newCreated = false;
	//Prefeb of Gameobject "Line0"
	public GameObject rendererPrefab;
	private GameObject panel;
  </pre>
  以上のスクリプトで使われる関数：
　<pre>
	//マウスは「DrawingPanel」のエリアにあるがどうか確認する
	bool IfInDrawingCanvas(){
		if (Screen.height - Input.mousePosition.y < (-panel.GetComponent<RectTransform> ().offsetMax.y) ||
		   Screen.height - Input.mousePosition.y > (Screen.height - panel.GetComponent<RectTransform> ().offsetMin.y)) {
			return false;
		}
		if (Input.mousePosition.x < panel.GetComponent<RectTransform>().offsetMin.x || 
			Input.mousePosition.x > (Screen.width + panel.GetComponent<RectTransform>().offsetMax.x)){ 
			return false;
		}
		return true;
	}
	//「DrawLine」を初期化する
	public void init(){
		used = true;
		isMousePressed = true;
		pointList.RemoveRange (0, pointList.Count);
	}
  </pre>
  </li>
  <li><b>ヒント</b><br/>
  複数の線を描く方法を紹介しましだが、もし、一本の線だけを描きたい場合、<a href="http://qiita.com/kwst/items/ad61e72562a8bcd9a9f7">こちら</a>をご参照して下さい。
 </li>
  <li><b>ディスカッション</b><br/>
  ブラッシュの色とサイズを変えてみますか？┃難易度★★★☆☆
  <br/><b>【アンサー】</b>
　</br><a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/DrawLine.cs">答え</a> 
search key: Discussion 3 Set linerenderer's color and size
  <br/><a href="#discussionanswer">答えを探す方法</a>
</li>
</ul>
<span><a href="#keyquestion">リストに戻る</a></span>

<h2 id="q3">『機能三』　画像の保存と取得（ファイルストア）</h2>
<h5>難易度/★★☆☆☆</h5>
<ul>
  <li><b>mBaaSのファイルストア機能について</b><br/>
  	<p>mBaaSが提供している、画像やテキスト、音楽などさまざまな種類のファイルを保存することができるストレージ機能です。
  	詳しくのは<a href="http://mb.cloud.nifty.com/doc/current/filestore/basic_usage_unity.html">ドキュメント</a>を参考下さい。
  	</p>
  </li>
  <li><b>説明対象</b><br/>
  【シーン「draw」】<br/>
  「Controller」Component<b>「SaveImage」</b>(Script)
  </li>
  <li><b>主な流れ</b>
  <h5>Step 1 スクリーンショットで画像ファイルをゲットする</h5>
  <p>画像おファイルをゲットする機能は、「SaveImage.cs」の「saveImage()」関数で行います。スクリーンショットの範囲は、インプットされたGameobjectがあるエリアだけです。</p>
  <pre>
  	public void saveImage (GameObject go) {
		float width = Screen.width + go.GetComponent<RectTransform>().offsetMax.x - go.GetComponent<RectTransform>().offsetMin.x;
		float height = Screen.height - go.GetComponent<RectTransform> ().offsetMin.y + go.GetComponent<RectTransform> ().offsetMax.y;
	
		renderTexture = new RenderTexture (Screen.width, Screen.height, 0);
		camera.targetTexture = renderTexture;
		camera.Render ();

		RenderTexture.active = renderTexture;
		Texture2D virtualPhoto =
			new Texture2D((int)width, (int)height, TextureFormat.RGB24, false);
		// false, meaning no need for mipmaps
		virtualPhoto.ReadPixels( new Rect(go.GetComponent<RectTransform>().offsetMin.x, 
			go.GetComponent<RectTransform>().offsetMin.y, 
			width, height), 0, 0);

		RenderTexture.active = null; //can help avoid errors 
		camera.targetTexture = null;

		//pngに転換する
		byte[] bytes;
		bytes = virtualPhoto.EncodeToPNG();
		saveToCloud (bytes,getName());
	}
  </pre>
  <h5>Step 2 画像をクラウドに保存する</h5>
  <p>ここで、mBaaSのSDKを使います。簡単なコードで、クラウドに保存できます。
  <ul><li>以下のコードで使われる関数「saveImageData()」は、次の機能で解説します。</li></ul></p>
  <pre>
  	void saveToCloud(byte[] bytes, string name){
		NCMBFile file = new NCMBFile (name, bytes);
		file.SaveAsync ((NCMBException error) => {
			if (error != null) {
				Debug.Log("upload error");
                showError(error);
				// 失敗
			} else {
				saveImageData(name);
			}
		});
	}
  </pre>
  <h5>Step 3 Unityの設定</h5>
  <p>「SaveImage.cs」をシーン「Drawing」の中の「Controller」にドラッグ＆ドロップして、MainCameraを「Camera」の所にドラッグします。（<a href="readme-img/07SaveImage.gif">動画を見る</a>）</p>
  <img src="readme-img/f3-01.jpg"/>
  </li>
  <li><b>動作確認</b><br/>
  	先ほどクラウドに保存されたDoodleはダッシュボードのファイルストアで見られます：
  	<img src="readme-img/f3-02.png"/>
  </li>
  <li><b>ディスカッション</b>
  <br/>クラウドから画像を取得する機能を追加しませんか？ ┃難易度★☆☆☆☆
  <br/>クラウドから取得した画像のタイプはbyte[]ですが、どうやってUnityが表示できるタイプに変換しますか？ ┃難易度★★☆☆☆
  <br/><b>【アンサー】</b></br>
  <a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/ThemeImageController.cs">画像取得の答え</a>
  search key: Discussion 4 Load from cloud<br/>
  <a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/ThemeImageController.cs">byte[]の答え</a>
　search key: Discussion 5 Deal with byte[] data<br/>
  <a href="#discussionanswer">答えを探す方法</a>
  </li>
  <li><b>ヒント</b>
  <br/>- ログインと同じ、ファイルの保存と取得も同時処理ではありません。
  <br/>- クラウドに保存したファイルは、mBaaSの<a href="https://console.mb.cloud.nifty.com">管理画面</a>で見られまが、
  ダッシュボードの「アプリ設定」⇒「データ-ファイルストア」の「HTTPSでの取得」を「有効」にすると、ファイルの公開URLが取得できます。とても便利な機能です。
  </li>
</ul>
<span><a href="#keyquestion">リストに戻る</a></span>


<h2 id="q4">『機能四』　画像に関するデータの保存と取得（データストア）</h2>
<h5>難易度/★☆☆☆☆</h5>
<ul>
  <li><b>mBaasのデータストア機能について</b><br/>
  	<p>mBaaSが提供している、アプリで利用されるデータを保存・共有することができるデータベース機能です。
  	詳しくのは<a href="http://mb.cloud.nifty.com/doc/current/datastore/basic_usage_unity.html">ドキュメント</a>を参考下さい。
  	</p>
  </li>
   <li><b>説明対象</b><br/>
  【シーン「draw」】（データを保存する場合）<br/>
  「Controller」Component<b>「SaveImage」</b>(Script)
  <br/>【シーン「doodles」】（データを取得する場合）<br/>
  「Controller」Component<b>「ThemeImageController」</b>(Script)
  </li>
  <li><b>主な流れ</b>
  <p>
  	ファイルストアには、画像ファイルのみが保存されます。絵の作者やタイプ（Doodleかテーマか）などの情報を一緒に管理するにはデータストアを利用します。データストアでは、「DoodleRecord」というクラスを使って、画像に関するデータを保存·管理しています。
  </p>
  <h5> データを保存する場合
  <p>
  	<ul>
  	<li>「SaveImage」スクリプトの中で、mBaaSのSDKを使ったデータを保存する処理：</li>
  </p>
  	<pre>
  	void saveImageData(string filename){
		NCMBObject obj = new NCMBObject ("DoodleRecord");
		obj.Add ("username", Configuration.username);
		obj.Add ("filename", filename);
		obj.Add ("date", DateTime.Now.Date);
		obj.Add ("theme", Configuration.theme);
		obj.Add ("likes", 0);
		
		obj.Save ((NCMBException e) => {      
			if (e != null) {
				Debug.Log("save data error");
			} else {
				//成功時の処理
				if(Configuration.status == Status.newTheme){
					Application.LoadLevel("themes");
				}else if(Configuration.status == Status.newDoodle){
					Application.LoadLevel("doodles");
				}
			}                   
		});
	}
  	</pre>
  <h5>データを取得する場合</h5>
  <p>
  	<ul>
  	<li>画像ファイルのURLも含め、Doodleに関するデータはデータストアの「DoodleRecord」クラスで保存されています。Doodleを表示する前に、先ずはDoodleRecordから画像のデータを取得します。</li>
  	<li>データを取得する時、先ずは検索の条件を決めます。sqlと同じ、mBaaSのSDKは、「NCMBQuery.WhereEqualTo(KEY,VALUE)」、「limit」、「skip」などの関数を使って、検索条件を指定することができます。詳しくは<a href="http://mb.cloud.nifty.com/doc/current/datastore/basic_usage_unity.html#基本的な検索の利用">ドキュメント</a>をご参考ください。</li>
  	<li>以下のコードは、シーン「doodles」のGameobject「Controller」のComponentの一つ「ThemeImageController」の中にあります。</li>
  	</ul>
  </p>
  <pre>
  	void loadImages(){
		NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject> ("DoodleRecord");

		query.WhereEqualTo ("date", DateTime.Now.Date);
		query.WhereEqualTo ("type", pictureType);
		if (pictureType == "doodle") {
			query.WhereEqualTo ("theme", Configuration.theme);
		}
		query.OrderByDescending ("createDate");
		//取得件数の指定
		query.Limit = maxCountInPage;
		//取得開始位置の指定
		query.Skip = page * maxCountInPage;
		query.FindAsync ((List<NCMBObject> objList ,NCMBException e) => {
			if (e != null) {
				//検索失敗時の処理
			} else {
				//Scoreが7のオブジェクトを出力
				foreach (NCMBObject obj in objList) {
					//ファイルネームに通し、画像をクラウドからダウンロードする
					NextImageIndex();
					imageData.Add(obj);
					InitLike(nowImageIndex);
					loadOneImageTo(obj["filename"].ToString(), nowImageIndex);
				}
			}
		});
	}
  </pre>
  </li>
  <li><b>動作確認</b><br/>
  	先ほど保存したDoodleに関するデータはダッシュボードのデータストアで確認できます：
  	<img src="readme-img/f4-01.png"/>
  </li>
  <li><b>ヒント</b>
  <br/>- データを保存する場合、NCMBObject.save()とNCMBObject.saveAsync()の二つの関数を使えられます。save()は同時処理で、saveAsync()は非同時処理ですが、どちらを使うのは状況次第です。
  </li>
</ul>
<span><a href="#keyquestion">リストに戻る</a></span>


<h2 id="q5">『機能五』　人気ランキング機能（データストア）</h2>
<h5>難易度/★★★☆☆</h5>
<ul>
  <li><b>mbのデータストア機能について</b><br/>
  	<p><a href="#q4">問題四</a>の「mBaaSのデータストア機能について」部分をご覧ください。
  	</p>
  </li>
  <li><b>ランキング機能の説明</b><br/>
  	<ul>
  	<li>「Doodle」のランキング機能は、Twitterの「いいね」と似て、作品を気に入った人の数で決めます。Doodleの右上のハートマークをクリックすると、ハート全体が赤くなって、「このDoodleに気に入った」になります。
  	<img height="200px" src="readme-img/f5-01.png"/></li>
  	<li>赤くなったハートをもう一度クリックすると、以上のアクションを消すことができます。</li>
  	<li>
  	一番人気なDoodleは、ゲームのメイン画面の左に表示します。そのDoodleをクリックすると、人気一位から四位までのDoodleが見られます。
  	<img height="200px" src="readme-img/f5-02.png"/></li>
  	</ul>
   </li>
   <li><b>説明対象</b><br/>
    【シーン「doodles」】<br/>
    「Controller」Component<b>「ThemeImageController」</b><br/>
   </li>
  <li><b>主な流れ</b>
  	<h5>Step 1 ハートマークのSpriteの定義と取得</h5>
  	<ul><li>Gameobjectの「Controller」に貼り付けっている「ThemeImageController」スクリプトの中で、以下の変数を定義します。
	<pre>
	//空きハートのSprite
	public Sprite likeSprite;
	//赤くなったハートのSprite
	public Sprite likeClickedSprite;
	</pre>
	</li>
  	<li>
  	この二つのハートマークを定義したら、UnityからSpriteファイルを取得します。（<a href="readme-img/08LikeSprite.gif">動画を見る</a>）<br/>
  	<img src="readme-img/f5-03.jpg"/>
  	</li>
  	</ul>
  	<h5>Step 2 ハートマークの切り替え、データの保存</h5>
  	<ul>
  	<li>ハートマークをクリックする時、更新すべきデータが二箇所あります。<br/>
  	1. 「データストア」⇒　クラス「DoodleRecord」 ⇒　「likes」<br/>
  	   &nbsp;&nbsp;&nbsp;&nbsp;DoodleRecordでは、Doodleに関するデータが保存されています。「likes」という列は、このDoodleに気に入った人数です。
  	<img src="readme-img/f5-04.jpg"/>
  	2.  「データストア」⇒ 　クラス「LikeRecord」⇒　新規記録<br/>
  	&nbsp;&nbsp;&nbsp;&nbsp;LikeRecordでは、「気に入った」というアクションの記録が保存されてしています。<br/>
	<img src="readme-img/f5-05.jpg"/>
	</li>
	<li>
	ハートマークをクリックするアクションは、「ThemeImageController」スクリプトのLightUpLike(INDEX)関数で処理します。インプットされた「index」は、シーンの中のハートマークのインデックスです（４つのハートマークがありますから、インデックスは１から４です）。
  	<pre>
  	public void LightUpLike(int index){
  		//まだクリックしてない場合
		if (this.likes [index].sprite == likeSprite) {
			//ハートマークを切り替え
			this.likes [index].sprite = likeClickedSprite;
			//好きな人数を取得
			int likeCount = int.Parse(imageData[index]["likes"].ToString());
			//人数を更新し
  			likeCount++;
  			imageData[index]["likes"] = likeCount;
			//「誰がどれを好き」の記録を保存する
			SaveLikeData (NCMBUser.CurrentUser.ObjectId,  imageData[index]["filename"].ToString());
		//クリックした場合	
		} else if (this.likes [index].sprite == likeClickedSprite) {
			this.likes[index].sprite = likeSprite;
			int likeCount = int.Parse(imageData[index]["likes"].ToString());
			likeCount--;
			imageData[index]["likes"] = likeCount;
			//「誰がどれを好き」の記録を消す
			DeleteLikeData (NCMBUser.CurrentUser.ObjectId, imageData[index]["filename"].ToString());
		}
		//好きな人数を更新する
		imageData[index].SaveAsync ((NCMBException e2) => {      
			if (e2 != null) {
			//エラー処理
			} else {
			//成功時の処理
			}                   
		});
	}
	</pre>
	</li>
	<li>ハートマークが赤くなったら、「このDoodleに気に入った」というアクションをデータストアに保存します。そのため、クラス「LikeRecord」で新しいレコードを生成します：</p>
	<pre>
	void SaveLikeData(string user, string doodle){
		NCMBObject obj = new NCMBObject ("LikeRecord");
		obj.Add ("doodle", doodle);
		obj.Add ("user", user);
		obj.Save ((NCMBException e) => {      
			if (e != null) {
				Debug.Log("save like data error");
			} else {
				//成功時の処理
			}                   
		});
	}
	</pre>
	</li>
	<li>もし、一度赤くなったハートマークをもう一度クリックしたら、ハートマークはまた空白になります。それに対応して、LikeRecordを消す必要もあります：
	<pre>
	void DeleteLikeData(string user, string doodle){
		//LikeRecordを検索するクラスを作成
		NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject> ("LikeRecord");
		query.WhereEqualTo ("user", user);
		query.WhereEqualTo ("doodle", doodle);
		query.FindAsync ((List<NCMBObject> objList ,NCMBException e) => {
			if (e != null) {
				//検索失敗時の処理
			} else {
				foreach (NCMBObject obj in objList) {
					Debug.Log ("delete objectId:" + obj.ObjectId);
					obj.DeleteAsync ((NCMBException deleteError) => {
						if (deleteError != null) {
							//エラー処理
						} else {
							//成功時の処理
						}
					});
				}
			}
		});
	}
  	</pre>
	</li>
	</ul>>
  </li>
  <li><b>ディスカッション</b>
  <br/>以上の流れに通し、「気に入り」機能を作成できました。あと一歩で、ランキング機能を完成できます。クラス「DoodleRecord」の列「Likes」（Doodleに気にりった人数）を使って、最後の一歩を御自身で試してみませんか？難易度★★☆☆☆
  <br/><b>【アンサー】</b></br>
  <a href="https://github.com/ellentby/Doodle-DrawTogether/blob/tutorial/Assets/script/BestImageReader.cs">答え</a>
  search key: Discussion 6 Like Ranking<br/>
  <a href="#discussionanswer">答えを探す方法</a>
  </li>
</ul>
<span><a href="#keyquestion">リストに戻る</a></span>


<h2 id="discussionanswer">ディスカッションの答えを探す方法</h2>
<p>1. 提供されたリンクをクリックして下さい。<br/>
2. Ctrl+Fを押して下さい（MACの場合、Command＋F）。<br/>
3. 現れた検索ボクスに提供されたsearch keyを入力し、「Enter」を押して下さい。
<img src="https://mb.api.cloud.nifty.com/2013-09-01/applications/JH0HWGCunFwimk6Q/publicFiles/searchbox.JPG"/><br/>
4. 検索結果とその下のコードはあなたが探したい答えですよ！(つ´ω`)つ<br/>
<a href="readme-img/09SearchAnswer.gif">動画を見る</a>
</p>
<span><a href="#keyquestion">機能リストに戻る</a></span>
